- server
    - new(接続サーバー) 接続サーバーのサーバー接続メソッドを呼び出し接続する
    - 公開鍵
    - 接続サーバー+それぞれの信頼度
    - 台帳<ブロックのtree>
    - サーバー接続
    - ブロック作成 新しいブロックを作成して台帳に繋ぎ、そのブロックを他の接続サーバーに送信する
        繋ぐ元は下を参照
    - ブロック受信 送信されたブロックが存在しなければ、そのブロックを台帳に加え、他の接続サーバーに送信する
    - 作成中ブロック チェーンに書き込んだブロックを記録し、後続が十分に長くなったら削除、後続が続かなければ再度書き込みを行う

- block
    - 前のブロックのハッシュ
    - timestamp
    - データ
    - 署名

分岐時は？
    信頼度の高い方に繋げる
    長い方に繋げる
        どっちを優先？長い方でも信頼度が低い人のチェーンなら短い方に繋げるべき
    短くなったブロックの作成者は適当なタイミング？で破棄する
        差が二つついたときとか？
        破棄するというか作り直す

攻撃者
    攻撃対象が取引したら、その取引と分岐するように適当なブロックを作成する

故意の分岐
    チェーンが一本でも途中の取引が信頼できないとき

bitcoin 的なのじゃなくて Permissioned っぽい

全てのworkerを終わらせてから動く
最初に一つのコアノードが接続先を管理

トランザクション管理も表現したい（サーバーをインスタンスとして神の視点からブロックとサーバー作成を行うときだけ表現できる、独立サーバーの場合は指示を出せるサーバーも複数あるので無理）
時間は基本的に止めておいて、空文字が入ったら1ステップ進める（接続先にブロックを書き写す）
skipで変わらなくなるまで進む（できる？）

Treeの表示
①全て表示
左端に最長ルートを書く
右に線出して捨てられた(?)ルート書く
最大8文字出す→1ノード10文字使用
文字列の二次元配列で処理、[0][0]がルート

s.t.
根は[0][0]
左端(∀x[x][0])は最長ルート
[x][y]のn個の子は[x+1][y], [x+1][y+1], ..., [x+1][y+n]、ただし子の持つ最長ルートが長い順
深さ優先で子を置いていく、複数あれば子の最大深さで並べる

二次元配列化と空白挿入で別ステップにする？
下から作って上で空白を作る必要があることが分かった時点で下にも空白挿入する？

長さが短い順にソート
1.木構造を二次元配列化
1.1.リストを深さが浅い順に入れた二次元配列（mutable）に入れる
	これの順番を左右に入れ替えて空ブロックを入れるだけ
	入れ替えが難しいので新しい配列に入れる、元を source, 入れる先を dest とする（sourceはmapになったが本質的には同じ）
1.2.最も深いノードを取ってきて、その親となるものを source から dest に移動（dest の左端に最も深くまで届くノードが入る）（木の「幹」の作成）
1.3.source リストのうち、中身が残っているものを下から順に確認：すべてのリストを確認
1.3.1.親ノードが存在しない（sourceに移動した）ノードをまとめて dest に移動
1.3.2.順番整理（枝が長い順にソートする必要はない）
1.3.2.1.親ノードと同じ順になるように子ノードをソート
1.3.2.2.親ノードが自分より左にあり、親ノードの真下が子ノードとなっていないとき、親ノードと自分が長男となる親すべてが真上に来るように親ノードと自分が長男となる親すべての左に空ノードを挿入する
	長男：共通の親ノードを持つノードのうち、自分が左端に来たノード
	先に葉に近い方から処理されるため、根のほうから伸びて自分の右に来るノードを考える必要はない
	親を先に動かす必要がある、その後子を右に動かすことによって
1.3.2.3.親ノードが自分より右にあれば、真上に来るように、移動したノードの左に空ノードを挿入する

1.3.3. 1.3を下からやり直す

下から確認する：枝が幹に近いものから出力するため、根から先に延ばすと後から出てきたものと交叉する
brockchain の性質から分かれた枝はあまり長くならないので、分岐が見つかったらその分岐を葉まで繋げるために上から確認しても下から確認してもあまり時間は変わらない

2.文字列化
2.1.全ての要素をメッセージのみに変換、8文字以上なら9文字目を「.」にして省略する
3.線をつくる
    1つ10文字の二次元文字列配列、[x-1][y]は上に木構造の[x][y]が来る
3.1.線の[x][y]を決める
        木構造で、空のものをスキップして、[x][y]の一つ右を[x][r]、一つ左を[x][l]とする。[x][y]の右・左がすべて空か、存在しないときは空とする（l<y<r）
        木構造の[x+1][y]が存在し、[x][y]の子であるとき（上下に繋げる必要があるとき）
            さらに木構造の[x][y], [x+1][r] が親子関係のときは「┣」に「━」を9個
            そうでないときは「┃」に「 」を9個
        木構造の[x+1][y]は存在するが、[x][y]の子ではないとき（上には繋げないが下には繋げるとき）
            [x+1][l], [x+1][y], [x+1][r]の親が同じとき（左右の親が同じとき）は「┳」に「━」を9個
            [x+1][l], [x+1][y]の親が同じとき（左のみ親が同じとき）は「┓」に「 」を9個
            （そうでないときは存在しないはず）
        [x+1][y]が空のとき（上下どちらにも繋げないとき）
            [x+1][r]が空のとき、もしくは[x+1][r]の親が[x][r]のとき、「 」を10個（[x+1][r]と[x][r]が「┃」「┣」で繋がるため、それより左の親子関係は不要）
            そうでないとき（[x+1][r]の親が[x][r]でないとき）、「━」を10個（[x+1][r]の親が[x][y]より左にあるため）
4.出力

②最長ルートだけ表示
最後のblock付近は最長ルートが複数ある可能性があることに注意

③付近nブロックだけ表示
全部出力するのは真面目に動かしてるものは大変なことになる



各々のサーバーを実際に立てる
	自分から動く(?)関数（connect, createBlock, sendLedger, showTree）はコマンドライン入力
	受信して動く関数（receiveConnection, receiveBlock, receiveLedger）は get で受け取る
	showTree は自分のものだけ見られるようにする？
	receiver が二つに分かれる

main 関数: サーバーとコマンドラインを起動するだけ
	コマンドライン起動: インスタンス実装を使いまわす（自分から動く処理は全部入っている）
	他サーバーからの受信: receiver.actualserver.MessageRoute -> Server
Receiver: 文字列を型に変換して実際に処理を行う Server に投げる
Server: 送信するタイプ以外はほぼ instance と同じ
	送信するタイプ: 送受信処理は server.actualserver.APICaller で行う、シングルトン、型変換も APICaller 内で行う

Koin で DI する
